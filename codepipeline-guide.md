# AWS CodePipeline Guide

*Last updated: 8/1/22*

This guide is for setting up a CI/CD pipeline with a Spring Boot and Maven project. It will use GitHub for source, AWS CodeBuild for build, and AWS Elastic Beanstalk for deploy.

1. We'll start by setting up Elastic Beanstalk for the deploy step later. This will allow us to have the RDS URL when we set environment variables later.
2. Go to Elastic Beanstalk and choose Create a new environment.
3. Choose Web server environment.
4. Give the application a name and give the environment a name as well.
5. You may want to give the environment a domain for accessing the app, although this is optional if you don't mind having an autogenerated value.
6. Under Platform, choose Java. You can leave the other settings default, or change the branch to Corretto 8 if you want it to be running Java 8.
7. Under Application code, choose Upload your code.
8. Upload the .jar file for your project. If you haven't created it yet, just run `mvn package` in the same folder as your `pom.xml` and you'll find the jar file in the `target` folder.
9. Click Configure more options at the bottom.
10. Scroll down to Database and click Edit.
11. Leave the snapshot section as None and go to Database settings.
    - **NOTE: BEFORE YOU CREATE THIS RDS, MAKE SURE THAT YOU DON'T HAVE ANY OTHER RDS INSTANCES CURRENTLY RUNNING.** Free tier only allows a certain amount of RDS hours and those hours are calculated with only one RDS instance, so **you want to avoid having multiple instances if you want to avoid charges.** Go to RDS and terminate any other instances you have.
    - Creating the RDS for your application here is valuable because the EC2 will already have access to the RDS via the security group by default, so you don't have to go and set that up. If you prefer to use an RDS you already have and skip these next few steps, you'll just need to figure out which security group your Elastic Beanstalk environment is in and add it to the RDS's inbound rules.
12. Set the engine to `postgres`.
13. Set the instance class to `db.t3.micro` as this is the free tier RDS.
14. You can leave the default storage value.
15. Set the username and password. Remember what you set them to because you'll need them in order for your application to access this RDS. I recommend that the username is `postgres`.
16. Under Database deletion policy, choose Delete. This will make sure that the database is terminated when you delete the Elastic Beanstalk environment.
17. Click Save.
18. Finally, click Create environment.
    - This may take a few minutes as it provisions the necessary resources (EC2, RDS, etc.).
    - If this fails the first time, that's okay - you just need to have this initial setup for the pipeline to use.
19. Now that the environment has been created, you can go to the RDS console in AWS and find the created RDS instance. Add your IP to its security group so that you can set up the database as needed via DBeaver/PgAdmin/etc.
    - You also will probably want to grab the hostname so that you can create your JDBC URL for Spring.
20. Go to AWS CodePipeline and choose to create a new pipeline.
21. Give the pipeline a name and create a new service role.
    - This role is an IAM role. If you need to view/modify/delete it for any reason, you can find it in IAM.
    - If you *do* find that you need to change the role later, make sure that you don't update the default, as the pipeline cannot use the role if the default version is modified.
22. After giving the service role a name, everything else can remain default. Click Next.
23. Under Source provider, choose Github (version 2).
24. Under connection, click Connect to GitHub and set up a connection with the repository that you're working with.
25. Set the repository name and the branch you want to use in your pipeline (most likely `main`).
26. Everything else can remain default. Click Next.
27. Under Build provider, choose AWS CodeBuild.
28. Under Project name, click Create project to create the project on CodeBuild.
29. Give the project a name. You can have it match the pipeline name or make it something different.
30. Under Environment, choose Managed image and set the operating system to Amazon Linux 2.
31. Set Runtime to Standard, Image to the latest (4.0), and leave the rest default.
32. Under Additional configuration, set your environment variables.
    - For Spring, this might be things like `SPRING_DATASOURCE_URL`, etc.
    - If you are using SonarCloud, you can also set your `SONAR_TOKEN` environment variable here.
33. In Build specifications, you can leave everything default. You will need to create a buildspec.yml file in your repository at top level.
    - The `buildspec.yml` file is a configuration file for AWS CodeBuild that explains what the build steps are and any other relevant configuration. There is a guide for this [below](#buildspec-file).
34. You can leave everything else as the default and choose Continue to CodePipeline.
35. Back in CodePipeline, you can leave the environment variables blank since you set them in CodeBuild. If you didn't set them there, you can set them here, but it's unnecessary to set them twice.
36. Choose Single build and click Next.
37. Under Deploy provider, choose AWS Elastic Beanstalk.
38. Choose the application name and environment name of your previously created Elastic Beanstalk project, then click Next.
39. Review your choices, then click Create Pipeline. This will trigger an initial run through the pipeline to make sure that everything is working. 
    - Keep in mind that the Build step will be fairly slow; it typically takes several minutes as it needs to provision resources to run the build.

## Buildspec File

The `buildspec.yml` file is the configuration file that AWS CodeBuild uses in order to know what it's supposed to do during the build process. You can find the documentation [here](https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html).

Here is an example of the basic `buildspec.yml` configuration that you'll need for the guide above. Keep in mind that yml is a whitespace-based format, so each indent must be two spaces.

The build command is currently set to `mvn verify` as this will run `test` and `package`, but you will want to replace this with the specific `mvn verify` command provided by SonarCloud in configuration if you are using SonarCloud. See [the SonarCloud guide](./week4/sonarcloud.md) for information on that setup.

``` yml
version: 2.0

phases:
  build:
    commands:
      - mvn clean && mvn verify
  post_build:
    commands:
      - mv target/*.jar ./your-project-name.jar

  artifacts:
    files:
      - your-project-name.jar
```

What this `buildspec.yml` does is it sets the commands to be run for the build and post-build processes. The build commands above will run Maven goals, where `clean` will remove any previous .jar files and `verify` will run your tests and create the new .jar file.

The post_build command moves the created jar file from the target folder to the top level so that it's easier to provide it to the next step in CodePipeline. It also renames the jar file to whatever you want it to be.

The artifacts section specifies where the artifact can be found so that CodeBuild can provide it to the next step in CodePipeline.

Keep in mind that there are other things you can do in the `buildspec.yml`, such as set environment variables, run other commands during pre-build, build, and post-build, and more.